<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>预测结果查看器</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/viewer.css') }}">
</head>
<body>
    <div class="viewer-container">
        <header>
            <a href="/" class="back-btn">← 返回</a>
            <h1>预测结果查看器</h1>
            <div id="image-name-header" class="image-name-header"></div>
            <button id="export-btn" class="export-btn">导出结果</button>
        </header>
        
        <div class="viewer-main">
            <div class="image-container">
                <div class="image-wrapper" id="image-wrapper">
                    <img id="main-image" src="" alt="" class="zoomable">
                </div>
            </div>
            
            <div class="info-panel">
                <div class="image-notes-section">
                    <h4>图片备注</h4>
                    <div class="status-badges" id="status-badges">
                        <span class="status-badge" id="status-false-positive" style="display: none;">误检</span>
                        <span class="status-badge" id="status-missed" style="display: none;">漏检</span>
                    </div>
                    <textarea id="image-notes" class="notes-textarea" placeholder="输入图片备注..."></textarea>
                    <div class="shortcuts-hint">
                        快捷键: F=误检, M=漏检
                    </div>
                </div>
                
                <div class="detections-section">
                    <h4>检测结果</h4>
                    <div id="detections" class="detections-list"></div>
                </div>
                
                <div class="details-toggle">
                    <button id="toggle-details" class="toggle-btn">显示详细信息 ▼</button>
                </div>
                
                <div id="details-panel" class="details-panel" style="display: none;">
                    <div class="defect-types-section">
                        <h4>缺陷类型</h4>
                        <div id="defect-types" class="defect-types-list"></div>
                    </div>
                    
                    <div class="legend-section">
                        <h4>模型说明</h4>
                        <div id="legend" class="legend"></div>
                    </div>
                    
                    <div class="label-colors-section">
                        <h4>标签颜色</h4>
                        <div id="label-colors" class="label-list"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="navigation">
            <span id="image-counter" class="counter"></span>
            <div class="navigation-hint">使用 ← → 或 A D 键切换图片 | F=误检 M=漏检</div>
        </div>
    </div>
    
    <script>
        const resultId = '{{ result_id }}';
        let currentData = null;
        let imageList = [];
        let currentIndex = 0;
        let zoomLevel = 1;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let imageOffset = { x: 0, y: 0 };
        
        // Load results
        fetch(`/api/results/${resultId}`)
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('加载失败: ' + data.error);
                    return;
                }
                currentData = data;
                imageList = Object.keys(data.predictions);
                if (imageList.length > 0) {
                    currentIndex = 0;
                    updateViewer();
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('加载失败: ' + error.message);
            });
        
        function updateViewer() {
            if (!currentData || imageList.length === 0) return;
            
            const imgName = imageList[currentIndex];
            const pred = currentData.predictions[imgName];
            
            // Update image
            const mainImage = document.getElementById('main-image');
            mainImage.src = pred.image;
            mainImage.onload = () => {
                zoomLevel = 1;
                resetImagePosition();
            };
            // Update image name in header
            document.getElementById('image-name-header').textContent = imgName;
            
            // Update counter
            document.getElementById('image-counter').textContent = 
                `${currentIndex + 1} / ${imageList.length}`;
            
            // Update notes and status
            const notesTextarea = document.getElementById('image-notes');
            const statusBadges = {
                falsePositive: document.getElementById('status-false-positive'),
                missed: document.getElementById('status-missed')
            };
            
            // Load saved notes and status
            const imageNotes = pred.notes || '';
            const imageStatus = pred.status || null;
            notesTextarea.value = imageNotes;
            
            // Update status badges
            statusBadges.falsePositive.style.display = imageStatus === 'false_positive' ? 'inline-block' : 'none';
            statusBadges.missed.style.display = imageStatus === 'missed' ? 'inline-block' : 'none';
            
            // Update defect types (simplified - only labels)
            const defectTypesDiv = document.getElementById('defect-types');
            defectTypesDiv.innerHTML = '';
            
            if (pred.predictions && pred.predictions.length > 0) {
                const allLabels = new Set();
                pred.predictions.forEach(predGroup => {
                    predGroup.bboxes.forEach(bbox => {
                        allLabels.add(bbox.label);
                    });
                });
                
                Array.from(allLabels).sort().forEach(label => {
                    const labelItem = document.createElement('div');
                    labelItem.className = 'defect-type-item';
                    const labelColor = currentData.label_colors && currentData.label_colors[label] 
                        ? currentData.label_colors[label] 
                        : [128, 128, 128];
                    labelItem.innerHTML = `
                        <div class="legend-color" style="background-color: rgb(${labelColor.join(',')})"></div>
                        <span>${label}</span>
                    `;
                    defectTypesDiv.appendChild(labelItem);
                });
            }
            
            // Update legend (only in details panel)
            const legend = document.getElementById('legend');
            legend.innerHTML = '';
            if (currentData.model_infos) {
                currentData.model_infos.forEach((model, idx) => {
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    const styleDesc = model.style_desc || '实线';
                    const styleClass = `line-style-${model.line_style || 'solid'}`;
                    legendItem.innerHTML = `
                        <div class="legend-line-style ${styleClass}"></div>
                        <span><strong>${model.short_name || model.name}</strong> - ${styleDesc} (${model.type}${model.sub_type ? ' - ' + model.sub_type : ''})</span>
                    `;
                    legend.appendChild(legendItem);
                });
            }
            
            // Update label colors (only in details panel)
            const labelColorsDiv = document.getElementById('label-colors');
            labelColorsDiv.innerHTML = '';
            if (currentData.label_colors) {
                Object.entries(currentData.label_colors).forEach(([label, color]) => {
                    const labelItem = document.createElement('div');
                    labelItem.className = 'label-item';
                    labelItem.innerHTML = `
                        <div class="legend-color" style="background-color: rgb(${color.join(',')})"></div>
                        <span>${label}</span>
                    `;
                    labelColorsDiv.appendChild(labelItem);
                });
            }
            
            // Update detections (simplified, one line per detection)
            const detectionsDiv = document.getElementById('detections');
            detectionsDiv.innerHTML = '';
            
            if (pred.predictions && pred.predictions.length > 0) {
                // Collect all bboxes from all models
                const allBboxes = [];
                pred.predictions.forEach(predGroup => {
                    predGroup.bboxes.forEach(bboxInfo => {
                        allBboxes.push({
                            ...bboxInfo,
                            line_style: predGroup.line_style || 'solid'
                        });
                    });
                });
                
                // Sort by score (descending) or label
                allBboxes.sort((a, b) => {
                    if (a.label !== b.label) {
                        return a.label.localeCompare(b.label);
                    }
                    return b.score - a.score;
                });
                
                // Display each bbox in one compact line
                allBboxes.forEach(bboxInfo => {
                    const bboxItem = document.createElement('div');
                    bboxItem.className = 'bbox-item-compact';
                    const labelColor = bboxInfo.color || [128, 128, 128];
                    const styleClass = `line-style-${bboxInfo.line_style || 'solid'}`;
                    
                    // Format: [框] <标签名> (置信度分数)
                    bboxItem.innerHTML = `
                        <div class="bbox-indicator">
                            <div class="legend-line-style-compact ${styleClass}" style="border-color: rgb(${labelColor.join(',')}); color: rgb(${labelColor.join(',')});"></div>
                        </div>
                        <span class="bbox-label-compact">${bboxInfo.label}</span>
                        <span class="bbox-score-compact">(${(bboxInfo.score * 100).toFixed(1)}%)</span>
                    `;
                    detectionsDiv.appendChild(bboxItem);
                });
            } else {
                detectionsDiv.innerHTML = '<p class="no-detections">未检测到任何目标</p>';
            }
        }
        
        function navigateImage(direction) {
            currentIndex += direction;
            if (currentIndex < 0) currentIndex = imageList.length - 1;
            if (currentIndex >= imageList.length) currentIndex = 0;
            zoomLevel = 1;
            resetImagePosition();
            updateViewer();
        }
        
        function updateZoom() {
            const img = document.getElementById('main-image');
            img.style.transform = `translate(${imageOffset.x}px, ${imageOffset.y}px) scale(${zoomLevel})`;
        }
        
        // Image dragging functionality
        const mainImage = document.getElementById('main-image');
        const imageWrapper = document.getElementById('image-wrapper');
        
        mainImage.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left mouse button
                isDragging = true;
                dragStart.x = e.clientX - imageOffset.x;
                dragStart.y = e.clientY - imageOffset.y;
                mainImage.style.cursor = 'grabbing';
                mainImage.style.transition = 'none'; // Disable transition during dragging
                e.preventDefault();
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                imageOffset.x = e.clientX - dragStart.x;
                imageOffset.y = e.clientY - dragStart.y;
                updateZoom();
                e.preventDefault();
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) { // Left mouse button
                if (isDragging) {
                    isDragging = false;
                    mainImage.style.cursor = 'grab';
                    mainImage.style.transition = 'transform 0.1s'; // Re-enable transition
                }
            }
        });
        
        // Prevent context menu on right click during drag
        mainImage.addEventListener('contextmenu', (e) => {
            if (isDragging) {
                e.preventDefault();
            }
        });
        
        // Reset image offset when image changes or zoom resets
        function resetImagePosition() {
            imageOffset.x = 0;
            imageOffset.y = 0;
            updateZoom();
        }
        
        // Save notes and status
        function saveImageNotes() {
            if (!currentData || imageList.length === 0) return;
            
            const imgName = imageList[currentIndex];
            const notesTextarea = document.getElementById('image-notes');
            const notes = notesTextarea.value.trim();
            
            fetch(`/api/results/${resultId}/notes`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    image: imgName,
                    notes: notes,
                    status: currentData.predictions[imgName].status || null
                })
            }).catch(error => {
                console.error('Error saving notes:', error);
            });
        }
        
        // Set image status
        function setImageStatus(status) {
            if (!currentData || imageList.length === 0) return;
            
            const imgName = imageList[currentIndex];
            const notesTextarea = document.getElementById('image-notes');
            const statusBadges = {
                falsePositive: document.getElementById('status-false-positive'),
                missed: document.getElementById('status-missed')
            };
            
            // Toggle status if same status is pressed again
            const currentStatus = currentData.predictions[imgName].status;
            const newStatus = (currentStatus === status) ? null : status;
            
            currentData.predictions[imgName].status = newStatus;
            
            // Update badges
            statusBadges.falsePositive.style.display = newStatus === 'false_positive' ? 'inline-block' : 'none';
            statusBadges.missed.style.display = newStatus === 'missed' ? 'inline-block' : 'none';
            
            // Save to server
            fetch(`/api/results/${resultId}/notes`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    image: imgName,
                    notes: notesTextarea.value.trim(),
                    status: newStatus
                })
            }).catch(error => {
                console.error('Error saving status:', error);
            });
        }
        
        // Auto-save notes when typing stops
        let notesSaveTimeout;
        document.getElementById('image-notes').addEventListener('input', () => {
            clearTimeout(notesSaveTimeout);
            notesSaveTimeout = setTimeout(saveImageNotes, 1000); // Save after 1 second of inactivity
        });
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                // But allow status shortcuts even in textarea
                if (e.key === 'f' || e.key === 'F' || e.key === 'm' || e.key === 'M') {
                    if (e.target.tagName === 'TEXTAREA') {
                        e.preventDefault();
                        if (e.key === 'f' || e.key === 'F') {
                            setImageStatus('false_positive');
                        } else if (e.key === 'm' || e.key === 'M') {
                            setImageStatus('missed');
                        }
                    }
                }
                return;
            }
            
            // Status shortcuts: F = false positive (误检), M = missed (漏检)
            if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                setImageStatus('false_positive');
                return;
            }
            if (e.key === 'm' || e.key === 'M') {
                e.preventDefault();
                setImageStatus('missed');
                return;
            }
            
            // Navigation: Left/Right arrows or A/D keys
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                e.preventDefault();
                navigateImage(-1);
            }
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                e.preventDefault();
                navigateImage(1);
            }
            
            // Zoom controls
            if (e.key === '+' || e.key === '=') {
                zoomLevel = Math.min(zoomLevel + 0.2, 5);
                updateZoom();
            }
            if (e.key === '-') {
                zoomLevel = Math.max(zoomLevel - 0.2, 0.5);
                updateZoom();
            }
            if (e.key === '0') {
                zoomLevel = 1;
                resetImagePosition();
            }
        });
        
        // Mouse wheel zoom
        document.getElementById('image-wrapper').addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                zoomLevel = Math.max(0.5, Math.min(5, zoomLevel + delta));
                updateZoom();
            }
        });
        
        // Toggle details panel
        const toggleBtn = document.getElementById('toggle-details');
        const detailsPanel = document.getElementById('details-panel');
        let detailsExpanded = false;
        
        if (toggleBtn && detailsPanel) {
            toggleBtn.addEventListener('click', () => {
                detailsExpanded = !detailsExpanded;
                if (detailsExpanded) {
                    detailsPanel.style.display = 'block';
                    toggleBtn.textContent = '隐藏详细信息 ▲';
                } else {
                    detailsPanel.style.display = 'none';
                    toggleBtn.textContent = '显示详细信息 ▼';
                }
            });
        }
        
        // Export button handler
        const exportBtn = document.getElementById('export-btn');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                exportBtn.disabled = true;
                exportBtn.textContent = '导出中...';
                
                fetch(`/api/export/${resultId}`)
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(data => {
                                throw new Error(data.error || '导出失败');
                            });
                        }
                        return response.blob();
                    })
                    .then(blob => {
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `predictions_${resultId}.zip`;
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                        exportBtn.disabled = false;
                        exportBtn.textContent = '导出结果';
                    })
                    .catch(error => {
                        alert('导出失败: ' + error.message);
                        exportBtn.disabled = false;
                        exportBtn.textContent = '导出结果';
                    });
            });
        }
    </script>
</body>
</html>

